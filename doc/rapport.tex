\documentclass{article}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage{multirow}
\usepackage{footnote}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{url}

\usepackage[top=2cm, bottom=2.5cm, left=1.5cm, right=1.5cm]{geometry}

\title{Système Digital\\Rapport de projet}
\author{Elie Michel, Louis Garrigue, Nicolas Jeannerod et Aurélien Delobelle}
\date{27 janvier 2013}

\begin{document}

\maketitle

\section{Vue d'ensemble}

\begin{figure}[h]
\centering
\includegraphics{organisation.eps}
\caption{\label{orga} Organisation du projet}
\end{figure}
\paragraph{}Le but principal de ce projet est la conception d'un microprocesseur, mais c'est autour du simulateur que le projet s'organise, comme le montre la figure \ref{orga}.

\paragraph{}Ce simulateur reçoit des informations de trois types différents :
\begin{itemize}
	\item Le circuit à simuler
	\item L'état de la ROM (le programme, dans le cas de notre microprocesseur)
	\item Les entrées du circuit
\end{itemize}

\paragraph{}Il retourne ensuite les sorties du circuit. Il est intéressant de faire la distinction entre les entrées/sorties du circuit, qui se font en temps réel lors de la simulation et le chargement du circuit et de la ROM qui se font à l'initialisation, depuis des fichiers préalablement générés. Ces deux phases sont appelées respectivement \texttt{run} et \texttt{setup} et possèdent chacune un script éponyme à la racine de l'archive.


\paragraph{}Le microprocesseur est construit en utilisant minijazz et un préprocesseur permettant l'agrégation de plusieurs fichiers. Le programme est assemblé par le programme jupiter. L'entrée du circuit est reliée par l'intermédiaire du port série à un oscillateur carré réel et la sortie peut être reliée à deux afficheurs, l'un graphique et l'autre non.

\paragraph{}Pour tester le projet, il suffit normalement d'exécuter les scripts \texttt{setup} puis \texttt{run}. Différentes options sont accessibles en ouvrant les fichiers \texttt{final/input}, \texttt{final/core} et \texttt{final/output}.

\section{Simulateur}

Les sources et dépendances du simulateur se trouvent dans le répertoire \texttt{sim/}


\subsection{Utilisation}
\subsubsection{Installation}
\paragraph{}La compilation du simulateur nécessite make, ocamlopt, ocamldep, ocamllex et menhir. Le plus simple est d'utiliser Linux, bien que nous ayons également testé sous Windows \emph{via} cygwin. Il est probable que le simulateur fonctionne sous MacOS bien que nous n'ayons pas eu à disposition de telle machine.

\paragraph{}\texttt{make sim} compile uniquement le simulateur alors que \texttt{make} (ou \texttt{make all}) lance également un exemple d'utilisation. Le programme \texttt{sim} ainsi créé est autonome.
v
\subsubsection{Fonctionnement général}
Sim prend en entrée les fichiers suivants :
\begin{itemize}
	\item Un fichier netlist contenant la description du circuit (ordonnée ou non)
	\item Un fichier décrivant la ROM (facultatif)
\end{itemize}

\paragraph{}Le fichier ROM est facultatif. S'il n'existe pas, un avertissement est affiché dans la console mais la simulation est tout de même effectuée. La ROM est alors identiquement nulle.


\subsubsection{Syntaxe des différents fichiers}
La syntaxe de la netlist peut se trouver ici : (en seconde partie)\\
\url{http://www.di.ens.fr/~bourke/minijazz.pdf}

\paragraph{}La syntaxe du fichier de description de la ROM est la suivante :
\begin{itemize}
	\item Les valeurs sont représentées par des caractères : \texttt1 représente un bit activé tandis qu'un \texttt0 représente un bit désactivé.
	\item Les espaces et tabulations sont ignorées.
	\item Les retours à la ligne annoncent une nouvelle adresse mémoire.
	\item Des commentaires peuvent être ajoutés en fin de ligne après le caractère \texttt\#.
	\item Une ligne commençant directement par le caractère \texttt\# n'est pas considérée comme correspondant à une adresse.
	\item Les adresses sont écrite par ordre croissant en partant de 0. Si le fichier est plus long que la taille de la rom, le comportement du simulateur n'est pas défini.
	\item La première valeur entrée détermine la taille des mots de la mémoire. Les lignes suivantes sont automatiquement tronquées ou complétées par des 0. Veillez donc à ce que la première ligne ne soit pas vide !
          \item Les premiers bits rencontrés sont les bits de poids faible
\end{itemize}

\subsubsection{Syntaxe de la commande sim}
\paragraph{}Le seul paramètre obligatoire est le fichier netlist à simuler. Sim s'appelle
alors comme suit :
\begin{verbatim}
	sim [filename].net
\end{verbatim}

\paragraph{}Par défaut, le Sim utilise le fichier \texttt{rom.sim} pour la rom. Pour modifier le fichier de description de la rom, utiliser l'option \texttt{-rom [filename].sim}.

\paragraph{}L'opération d'ordonnement de la netlist a pendant longtemps nécessité d'attendre plusieurs dizaines de secondes, c'est pourquoi on peut choisir de sauvegarder la netlist ordonnée à l'aide de l'option \texttt{--schedule-only}. Dans ce cas, l'étape de simulation n'est pas effectuée et la netlist ordonnée est enregistrée dans \texttt{[filename].sch.net}.

\paragraph{}Lorsque l'on veut utiliser un fichier netlist déjà ordonné, il utiliser l'option \texttt{--sim-only}. À ce moment, si la netlist n'a pas préalablement été ordonnée, il peut y avoir des erreurs diverses. Le plus simple est de n'utilise cette option que lorsque le fichier termine par \texttt{.sch.net} afin d'éviter les confusions.

\paragraph{}Sim lit les valeurs des entrées du circuit sur l'entrée standard et écrit celles des sorties sur la sortie standard (sans retours à la lignes ni espaces dans les deux cas). L'entrée est lue bloc par bloc sans perdre une seule valeur, et donc si elle est générée plus vite qu'elle n'est traitée, un délais s'établit entre la génération et son envoi à la netlist simulée. Si ce comportement n'est pas souhaité, le paramètre \texttt{--async} peut être spécifié au lancement de Sim afin de vider l'entrée après l'avoir lue à chaque itération de la simulation. Ainsi la valeur lue en entrée a toujours été écrite pendant la dernière itération.

\subsection{Fonctionnement interne}

\paragraph{}Le simulateur peut se décomposer en plusieurs phases :
\begin{itemize}
	\item Le parseur de netlist
	\item L'optimizer, qui ordonne et simplifie les netlists
	\item Le parseur de fichier de ROM
	\item Le lecture/écriture des entrées/sorties du circuit
	\item L'initialisation, convertissant l'AST en structure plus adaptée à la simulation
	\item Le cœur du simulateur
\end{itemize}

\subsubsection{Parseur de netlist}
Nous avons globalement repris celui donné en TP au début de l'année. Nous avons cependant modifié les types \texttt{ty} et \texttt{value} pour abandonner les tableaux de booléens, trop peu efficaces et gourmands en mémoire, au profit d'une représentation sur basée sur la représentation binaire d'entiers. Le type est un entier spécifiant la taille de la nappe, ou \texttt0 pour un bit simple, et la valeur est un entier. Le seul problème est qu'on est alors limité dans les nappes par la taille des entiers caml (31 bits sur une architecture 32 bits) mais ce problème est résolu par la phase d'optimisation (sauf pour les accès mémoire).

\subsubsection{Optimizer}
\paragraph{}Les netlist générées depuis minijazz étant relativement longues, nous avons cherché à les optimiser. Nous nous sommes alors posé la question de l'utilité des nappes : leur  implémentation n'apporte aucune fonction spécifique (sauf RAM et ROM),  et n'accélère donc en rien la simulation.
De  plus, de part l'utilisation des circuits définis récursivement, le  nombre de fonctions SELECT, SLICE et CONCAT était vraiment élevé dans la netlist.
Dès lors, il y avait deux choix possibles :
\begin{itemize}
	\item conserver l'idée de nappe, et adapter les fonctions de base, AND OR NOT MUX à leur utilisation
	\item supprimer les nappes (si cela pouvait apporter de la rapidité)
\end{itemize}

\paragraph{}La première solution n'ayant pas vraiment de sens physique, nous avons opté pour la deuxième : supprimer la notion de nappe.
En  fait, nous n'avons pas tout à fait fait ça, dans la mesure ou nous ne  voulions pas supprimer les primitives ROM et RAM, qui utilisent  fondamentalement les nappes.
Presque toutes les nappes ont été supprimées, sauf localement autour des primitives RAM et ROM, ou elles sont reconstruites.

\paragraph{}C'est le travail du module Optimizer du simulateur de faire cela. Ce module améliore le travail de Scheduler :
\begin{itemize}
	\item il prend une valeur de type \texttt{Netlist\_ast.program} en entrée
	\item il ressort une valeur de type \texttt{Netlist\_ast.program}, avec les équations  triées dans un ordre topologique au niveau des dépendances.
\end{itemize}

\paragraph{}Il fait cependant mieux que ça, et ce pour plusieurs raisons.
En premier lieu, la complexité du travail de Optimizer est  en $\mathcal O(n)$ ou $\mathcal O(n\log n)$, quand celle du Scheduler était de $\mathcal O(n^2)$. Cela  est rendu possible par le fait que l'Optimizer stocke dans son graphe  (qui représente la netlist) plus d'informations (notament l'équation  associée au noeud), ce qui permet donc de retrouver l'équation associée à  un noeud en temps constant, au lieu de devoir chercher dans une liste  (en temps linéaire donc). Sur une netlist de ~25000 portes, cela  multiplie l'efficacité par (au moins) 1000, ce qui se ressent quand on  passe de 50s de préparation à la simulation à moins d'une seconde.

De plus, lors de la construction du graphe représentant la netlist,  l'Optimizer supprime les nappes. Une variable a:3 se verra remplacer par \texttt{a\-n0}, \texttt{a\-n1}, \texttt{a\-n2}. L'ordre  des variables étant important au niveau des inputs/outputs, ce détail  est bien sûr  contrôlé. Cela permet alors la suppression de la plupart des fonctions  SELECT, SLICE et CONCAT, qui deviennent simplement des égalités  bit-à-bit. À ce stade, le graphe comporte donc beaucoup plus de noeuds  que la netlist d'équations.
Lors  du retour à la netlist, on supprime les branches inutiles de la  netlist, à savoir toutes les équations qui ne servent pas au calcul des  outputs. La netlist est aussi triée par ordre topologique à ce moment.  Elle comporte beaucoup plus d'équations que l'orginal.

En   dernier lieu, on supprime  toutes les équations de la forme y=x (sauf  celles qui concernent une  output) et on remplace la variable y par la  variable x dans la netlist. Cette phase supprime énormément de portes, ce qui permet à la fin d'obtenir une netlist bien plus petite que l'original. Par exemple :
\begin{itemize}
	\item mjc.byte donne une netlist de 22143 portes
	\item après la suppression des nappes, on passe à 48384 portes
	\item après la suppression des doublons, 8132 portes.
\end{itemize}


\subsubsection{Parseur de la ROM}
La lecture des fichiers de description de la ROM est suffisemment simple pour tenir dans un lexer (pas besoin de menhir ici). Ce parseur servait à l'origine à charger le fichier décrivant les entrées au cours du temps.

\subsection{Entrées/sorties du circuit}
\paragraph{}Les entrées étaient au début écrites à l'avance dans un fichier lu au démarrage du simulateur, mais cette méthode atteint ses limites lorsque les informations envoyées à l'entrées devaient d'une part être infinies et d'autre part ne pouvait pas être prévues à l'avance. Nous avons alors choisi de dialoguer sur l'entrée/sortie standard (bien que ce soit en fait là aussi un fichier), en vue de la communication avec les autres parties du projet.

\paragraph{}Les entrées étaient initialement séparées d'un retour à la ligne entre chaque série et typées (les nappes mises entre crochet) pour vérifier qu'elles correspondent à l'entrée attendu. Pour des raisons de performances, nous nous sommes contenté de lire les entrées successives bout à bout, sans aucune séparation. Dans la pratique, il n'y a en entrée qu'un seul bit et ce choix divise donc par deux la taille des fichiers échangés. Le même allègement est appliqué aux sorties.

\subsubsection{Initialisation}
Nous avons eu énormément de problèmes d'efficacité avec le simulateur et n'avons de ce fait pas conserver la structure telle qu'elle est chargée pour la simulation. Plutôt que d'indicer les différentes équations par leur nom dans le fichier de netlist, elles sont numérotées et un tableau les contenant est initialisé. Nous avons également tenté d'encoder l'arbre de syntaxe abstraite dans un autre tableau d'entier afin de se rapprocher au maximum du bas niveau mais les gains de performance n'étaient finalement pas intéressants.

\subsubsection{Simulation}
\paragraph{}Le simulateur se doit d'être le plus rapide possible. Nous avons commencé avec une fréquence d'à peu près 15Hz, ce qui ne permettait vraiment pas de simuler correctement une horloge, surtout avec notre jeu d'instruction extrêmement bas niveau.

\paragraph{}Les raisons de cette lenteur n'ont pas été simples à déterminer. Une première amélioration fut d'abandonner l'utilisation de maps au profit de tables de hachage (passage à 20-25Hz) mais la simulation restait étrangement lente. Ne trouvant pas d'où venait le problème, nous avons, avec l'aide de Tim, fait le profiling d'une simulation. Le profiling fourni par ocaml ne donne que le nombre d'appels à chaque fonction et nous n'avons rien repéré d'anormal. Nous avons cependant constaté que plus de la moitié des opérations étaient des concat/select/slice et c'est ce qui a motivé notre idée de retirer les nappes.

\paragraph{}Un profiling plus poussé à l'aide de \texttt{gprof} et du module \texttt{Gc} a montré que la représentation des nappes sous forme de tableaux de booléens mobilisait un peu trop la mémoire. Nous avons donc décidé de les représenter par des entiers malgré la perte de généralité engendrée (limite de taille des nappes). Un autre point que le profiling a montré est l'utilisation un très grand nombre de fois du hashage, c'est pourquoi nous avons numéroté les équations au lieu de les représenter par une chaîne.

\paragraph{}Les performances se sont améliorées jusqu'à avoisiner les 200Hz mais cette valeur nous semblait encore très faible au vu des capacités d'un ordinateur. Ne pouvant optimiser plus le simulateur sans tout recommencer, nous avons alors entreprit d'optimiser la netlist. Nous avons alors pu dépasser les 400Hz dans certains cas.

\paragraph{}Une dernière optimisation intéressante fut de couper le code du microprocesseur en deux et de simuler les deux parties séparément. Nous n'avons rien eu à modifier sur le simulateur et il a ainsi pu profiter des architectures multi cœurs.


\section{Microprocesseur}

\begin{wrapfigure}{r}{0.2\textwidth}
\begin{center}
\includegraphics[width=0.2\textwidth]{zoom_micro.eps}
\end{center}
\end{wrapfigure}

\subsection{Introduction}

Nous avons commencé par nous baser sur le fonctionnement des microprocesseurs
MIPS étant donné que c'était la seule architecture que nous connaissions.
Nous avons cependant tenu à faire quelque chose de différent.

\subsubsection{Ligne de conduite}
Notre premier choix important a été de décider que chaque fonction du
microprocesseur prendrait ses arguments dans les mêmes registres prévus à cet effet
(à savoir les \$a*), et renverrait ses résultats dans les registres prévus à
cet effet (les \$r*), à l'instar des appels système de MIPS qui regardent
toujours \$v0 et \$a0.

\subsubsection{Densité}
Ce choix nous a dirigé vers un objectif de densité. Nous avons alors constaté
qu'il était possible de ne conserver que 4 registres
\footnote{\$a0, \$a1, \$r0, \$r1}, réduisant par là énormément le nombre
d'instructions de gestion de la mémoire puisque nous n'avions donc  plus besoin
que de 2 bits pour choisir un registre.

Nous avons au début cherché la densité maximale, avec un très petit jeu
d'instructions (sur 5 bits seulement !).
Mais pour des raisons pratiques (pour que certaines manipulations ne prennent pas
trop d'instructions) nous l'avons enrichi. Finalement, les instructions sont
codées sur 6 bits.


\subsection{Architecture générale}

\subsubsection{Taille des valeurs}
Le choix de la taille en bit des valeurs manipulées par le microprocesseur est
un choix important et l'un des premiers que l'on ait fait. Il nous fallait trouver
un compromis entre petite taille et maniabilité.

Les valeurs à afficher dans l'horloge sont toutes, à l'exception de l'année, de
taille inférieure à 256 et le choix de mots de 8 bits nous ont semblés être un
choix raisonnable. Pour la gestion des années, nous avons choisi de découper en
deux bytes selon son écriture décimale et non binaire afin de simplifier la
conversion en 7 segments.

Ce choix a par la même occasion déterminé le nombre de cases mémoire puisque nous utilisons un registre pour choisir l'adresse. Une RAM de 256 adresses est largement suffisante pour programmer une horloge. Nous sommes cependant revenu sur ce choix par la suite. (\emph{cf}~\ref{micro_update})

\paragraph{Dans la ROM}
Il n'était par contre pas possible de se limiter à des programmes de 256 instructions
seulement, d'autant plus que notre jeu d'instructions extrêmement bas niveau nous
oblige à produire de longs programmes. Le curseur d'instructions est donc représenté
sur 16 bits, permettant des programmes de 65 636 instructions. Cette disparité
entre la taille des mots machine et celle du curseur d'instructions nous a contraint
à utiliser des sauts de taille relative plutôt qu'absolue. Il est cependant toujours
possible de spécifier des tailles absolues dans des cas où c'est nécessaire en
utilisant deux registres.

\subsubsection{Séparation en unités}
Nous avons séparé les instructions en 4 unités en fonction de leurs
deux premiers bits en langage machine :
\begin{itemize}
  \item SYS qui s'occupe des entrées et sorties de la machine (depuis
    l'horloge, et vers l'affichage).
  \item ALU qui fait les opérations de base, arithmétiques et logiques (add,
    sub, mult, div\footnote{La division est euclidienne} ; and, or, not, shift).
  \item MEM qui gère les accès mémoire, que ce soit entre registres ou entre un
  registre et la RAM.
  \item JUMP qui contrôle l'adresse de lecture des instructions.
\end{itemize}

\paragraph{Inconvénients}
La séparation en quatre unité impose un nombre fixe d'instructions possibles
par unité, ce qui a amené quelques choix discutables :
\begin{itemize}
  \item Par manque de place, le move d'un \$a[i] vers un \$a[j]
    (resp. \$r[i] vers \$r[j]) n'existe pas. On doit pour cela utiliser une
    étape intermédiaire.
  \item Nous avions absolument besoin du LI (load immediate), et ne trouvions
    pas de place pour cette instruction. Finalement, elle appartient à l'ALU.
  \item Pour certaines instructions, on ne peut regarder que dans \$a0 (et \$a1
    si deux arguments sont exigés), alors que pour d'autres on peut choisir
    le(s) registre(s) d'argument(s). Cela est dû au fait que certaines unités
    manquaient de place par rapport à d'autres.
  \item L'unité JUMP a accueilli les commandes WCA (Write Current Address) et
    END (termine le programme)
\end{itemize}


\subsubsection{Notes sur le load immediate}
Le LI est une instruction qui nous a posé problème car elle est en contradiction
avec la petite taille de nos instructions. En effet, l'instruction doit contenir
la valeur que l'on veut charger, ce qui n'est pas possible avec des instructions
plus petites que les mots machine.

\paragraph{}
Une première idée fut d'interpréter l'instruction d'après non pas comme une
instruction mais comme une valeur. En utilisant les 2 derniers bits de l'instruction
LI puis les 6 bits de l'instruction suivante, on pouvait charger toute valeur.

Le problème est que cela revenait en fait à faire des instructions de taille variable
et complexifiait le processeur. Gérer des tailles variables pour une seule instruction
manquait de cohérence et nous avons préféré faire un chargement partiel, ne gérant
pas toutes les valeurs possibles.

\paragraph{}
Il s'est ensuite posé la question du choix des valeurs à gérer. La réponse la plus immédiate
est de charger les bits de poids faible seulement. Une autre solution aurait
pu être de choisir des valeurs que l'on est plus susceptible d'utiliser pour l'horloge,
comme 24 ou 60, mais nous préfèrions conserver un minimum de généralité. Il était
également possible de choisir les nombres premiers pour simplifier la décomposition
en sous-étapes du chargement de valeurs plus importantes, mais nous n'avions la place
dans le jeu d'instruction de ne choisir que 8 valeurs et en ajoutant 0 et 1 on ne
pouvait aller que jusqu'à 11 (ou 13 sans 0), ce qui ne permet pas de décomposer
tout nombre représenté sur 8 bits. Finalement, nous avons donc conservé la première
solution.

\subsubsection{Notes sur le shift}
Une autre instruction à laquelle notre choix de densité a donné un comportement
particulier est le shift. On ne choisi pas à l'appel de cette fonction le sens dans
lequel se fait le décalage et pour cause, il se fait toujours vers les poids forts.
Si on veut faire un décalage de $n$ vers les poids faibles, il suffit en fait de
faire un décalage de $8 - n$ puis de regarder les poids forts du résultat seulement
(c'est-à-dire le registre \$r1).

\subsubsection{Notes sur les sauts conditionnels}
La densité joue également un rôle dans le fonctionnement des sauts conditionnels.
Plutôt que de faire une instruction \emph{branch if equal zero} prenant en argument
à la fois une adresse et un registre à tester, on ne regarde qu'un registre et on
laisse le choix du type (avant/arrière, absolu/relatif) et de l'amplitude du saut
à l'instruction suivante.

Une amélioration que nous pourrions envisager dans les instructions de saut est
l'ajout de sauts de taille fixe. Il y a à cela deux raisons :
\begin{itemize}
  \item Les instructions de saut relatif permettent de choisir un registre, contrairement
        à la philosophie que nous voulions adopter. C'est uniquement dû au fait qu'il
        restait de la place dans le jeu d'instructions de l'unité JUMP mais on pourrait
        parfaitement envisager de retirer certaines de ces instructions.
  \item Les sauts relatifs sont le cas le plus courant où il est nécessaire de charger
        une constante écrite sur plus de 3 bits et est donc fastidieux à programmer.
        Il serait donc bien plus simple d'avoir une instruction faisant un « grand »
        saut, même s'il est de taille fixe car on peut alors au besoin ajouter des
        instructions vides pour ajuster le répéter.
\end{itemize}

Il est à noter que ce comportement peut être simulé en enregistrant dans une case
mémoire facilement accessible (entre 0 et 7, pour qu'un LI suffise à charger son
adresse) une valeur élevée dès le début du programme, on peut émuler cette fonctionnalité.

\subsubsection{Stockage de la date/heure}
Nous imaginions d'abord réserver des adresses particulières de la RAM pour
stocker les valeurs de la date/heure. Le problème de cette méthode est que l'on
ne peut faire qu'un seul accès simultané à la RAM et il n'était donc pas possible
d'afficher ces valeurs en même temps. Nous avons donc utilisé une mémoire
spécifique : 7 registres en écriture seule branchés à la sortie font office
de mémoire graphique.

\paragraph{}
Ces registres ne peuvent cependant pas être modifiés simultanément, du fait de
notre jeu d'instruction réduit et de l'absence de 7 mémoire lisible simultanément.
Nous avons donc doublé la mémoire graphique afin de créer un système de \emph{double
buffering} : les modifications sont apportées à une mémoire tampon au fur et à mesure
du code et lorsque l'on appelle la commande FLIP, tous les registres d'affichage
sont modifiés simultanément. La date/heure est ainsi affichée en une seule instruction.

\paragraph{}
Nous tenions à implémenter l'intégralité de la logique en netlist, c'est pourquoi
la sortie de celle-ci est une suite de chiffre sous forme 7 segments, telle que l'on
pourrait imaginer la brancher directement sur les segments de l'afficheur sans
aucun traitement de la part de ce dernier. Les valeurs enregistrées dans la mémoire
graphique passent donc dans un module de conversion en affichage à 7 segments avant
d'être envoyées sur la sortie.


\subsubsection{Interactions entre les différentes unités}

On envoit à chaque unité son code opération (les quatre bits qui ne servent pas
à définir l'unité), et elle exécute cette opération. L'ALU par exemple, envoit
les valeurs \$a0 et \$a1 à chaque opérations, et reçoit tous les \$r0 et \$r1
associés. Elle mux alors selon le code opération qu'elle a reçu. De même, les
résultats des unités sont mux pour n'effectuer que l'action voulue. Selon
l'unité, ces résultats peuvent changer différents choses (les valeurs des
registres pour l'ALU, l'emplacement de la tête de lecture pour JUMP, etc).
Les instructions ayant généralement des effets de bord (le flip pour SYS,
la modification de la RAM pour MEM, les sauts pour JUMP), on indique à chaque
unité si elle doit agir ou pas.\\

\begin{figure}[h]
\centering
\includegraphics{archi.eps}
\caption{\label{archi} Architecture microprocesseur}
\end{figure}
\paragraph{}La figure \ref{archi} présente l'architecture microprocesseur et l'interaction
entre les différentes unités.


\subsubsection{GPU}
Derrière le module SYS se cache en fait un cinquième module : le GPU (\emph{Graphical Processing Unit}, je précise par principe bien que je me doute que vous en connaissiez le sens). Le GPU représente en nombre de portes la moitié de notre processeur et a pour rôle de convertir les entiers codés en binaire en une série de codages 7 segments. Le poids important de cette partie du circuit vient du fait qu'il doit gérer simultanément les 7 entiers affichés.

\paragraph{}Les deux actions les plus effectuées par le GPU sont les divisions euclidiennes par 10 et les conversions 4 bits binaires vers 7 segments (le comportement en cas de valeur supérieure à 9 n'étant pas spécifié). Nous avons tenté d'optimiser les divisions par 10, le diviseur étant connu statiquement, mais il s'est avéré que le nombre de portes n'était pas diminué. Il se peut que cette absence de différence entre la division générale et la division par une constante connue d'avance disparaisse lors de la phase d'optimisation du simulateur, mais nos tests datent d'avant l'existence de cette phase.

\paragraph{}La séparation CPU/GPU est un point très intéressant du circuit : il est central puisque le GPU représente la moitié du circuit, mais les liens entre les deux sont d'une part peu nombreux et d'autre part à sens unique. Cela nous a permis de couper la simulation en deux afin d'optimiser l'utilisation de processeurs multi-cœurs en lançant simplement deux occurences du simulateur.

\paragraph{}Notons que nous aurions pu choisir, au vu du son poids important, de gérer la logique du GPU directement dans l'afficheur. Mais nous tenions à jouer le jeu de la simulation jusqu'au bout et imaginer la sortie du simulateur directement branchée fil par fil aux 98 segments de l'afficheur.

\subsection{Ajout récent}
\label{micro_update}
Cette partie du microprocesseur n'était pas présente dans l'ancienne version rendue le 7 janvier mais s'est avéré être indispensable pour limiter le taille du programme.

\paragraph{}On a déjà remarqué que les premières adresses mémoire (de 0 à 7) sont relativement simple d'accès (un \emph{load immediat} suffit) alors que les adresses suivantes sont presque impossible à atteindre sans effacer presque tous les registres en pratique et donc inutilisables. L'idée que l'on a eu pour y remédier est d'ajouter un pseudo-registre, noté \$c, qui serait un curseur vers une adresse donnée de la RAM à partir duquel tous les accès mémoire se feraient. Un accès à l'adresse $x$ se fait ainsi en réalité à l'adresse \$c + $x$.

\paragraph{}Les opérations possibles sur ce pointeur \$c sont “ajouter 8” (INCR) et “retirer 8” (DECR), la valeur 8 correspondant au nombre d'adresses faciles d'accès. On enregistre en réalité $\frac{\$c}8$ étant donné que les 3 derniers bits sont toujours à 0. Cette méthode permet de limiter le nombre d'instructions à ajouter.

\paragraph{}Il devient ainsi très simple d'accéder aux adresses au-delà de 8, bien que le temps d'accès ne soit plus constant. On a également pu augmenter la taille de la RAM. Bien que ce système permette de gérer une RAM de taille quelconque, nous nous sommes contenté de $2^{16} = 65536$ adresses. Notre programme n'utilise en réalité que 8 chunks (24 adresses) mais par soucis de généralité nous avons voulu montré qu'il était possible de gérer une grande quantité de RAM et donc d'envisager de compiler n'importe quelle programme vers notre assembleur, ce que 256 adresses ne permet pas vraiment.

\begin{figure}[h]
\centering
\includegraphics{archi_update.eps}
\caption{\label{archi_update} Architecture microprocesseur mise à jour}
\end{figure}
\paragraph{}La figure \ref{archi_update} met en évidence la modification approtée sur le schéma du microprocesseur. On peut noter que nous avons dû faire une entorse à notre partitions en différentes unités : le curseur \$c, bien que relatif aux accès mémoire, est géré par le module système. C'était le seul endroit où il subsistait des adresses d'instruction libres.


\subsection{Jeu d'instruction détaillé}

\begin{savenotes}
\begin{longtable}{|c|l|l|}
  
  \hline
  Code & Nom & Description \\
  \endfirsthead
  \hline
  Code & Nom & Description \\
  \hline\hline
  \endhead

  \hline\hline
  00 ** ** & \multicolumn{2}{|l|}{SYS} \\
  \hline
  00 00 10 & INCR    & Incrémente le curseur de bloc. \\
  00 00 11 & DECR    & Décrémente le curseur de bloc. \\
  \hline\hline
  00 01 00 & INPUT    & \'Ecrit l'input dans un registre donné. \\
  00 1* ** & OUTPUT x & \'Ecrit la valeur de \$a0 dans la mémoire graphique x, avec 0 $\leq$ x $\leq$ 7 \\
  00 11 11 & FLIP     & Actualise l'affichage du timer avec ce qu'il y a dans sa mémoire. \\
  
  \hline\hline
  01 ** ** & \multicolumn{2}{|l|}{ALU} \\
  \hline
  00 00 ** & \multicolumn{2}{|l|}{Arithmétique} \\
  \hline
  01 00 00 & ADD   & Ajoute \$a0 et \$a1. Le résultat est dans \$r0, la retenue dans \$r1. \\
  01 00 01 & SUB   & Soustrait \$a1 à \$a0. Le résultat est dans \$r0\footnote{$\$r0=\$a0-\$a1$ est certifié uniquement si $\$a0>\$a1$}, la retenue dans \$r1. \\
  01 00 10 & MULT  & Multiplie \$a0 et \$a1. Le résultat est dans la concaténation de \$r0 et \$r1.\\
  01 00 11 & DIV   & Divise \$a0 par \$a1. Le quotient est dans \$r0, et le reste dans \$r1. \\
  \hline
  00 01 ** & \multicolumn{2}{|l|}{Logique} \\
  \hline
  01 01 00 & AND   & Calcule le AND bit-à-bit de \$a0 et \$a1 dans \$r0. \\
  01 01 01 & OR    & Calcule le OR bit-à-bit de \$a0 et \$a1 dans \$r0. \\
  01 01 10 & NOT   & Calcule le NOT bit-à-bit de \$a0 dans \$r0, et de \$a1 dans \$r1. \\
  01 01 11 & SHIFT & SHIFT \$a0 de min(\$a1,n) vers les poids forts. Le résultat est dans la concaténation de \$r0 et \$r1.\\
  \hline
  01 1* ** & LI x  & Charge une constante x à trois bits\footnote{Le reste est rempli de 0} dans \$a0. \\
  
  \hline\hline
  10 ** ** & \multicolumn{2}{|l|}{MEM} \\
  \hline
  10 0* ** & \multicolumn{2}{|l|}{entre registres} \\
  \hline
  10 00 ij & MOVE 0ij & Déplace un \$a[i] vers un \$r[j]. \\
  10 01 ij & MOVE 1ij & Déplace un \$r[i] vers un \$a[j]. \\
  \hline
  10 1* ** & \multicolumn{2}{|l|}{avec la RAM} \\
  \hline
  10 10 ij & LOAD ij  & Charge la valeur en RAM(\$r[i]) dans \$a[j]. \\
  10 11 ij & SAVE ij  & Enregistre dans RAM(\$r[i]) la valeur \$a[j]. \\

  \hline\hline
  11 ** ** & \multicolumn{2}{|l|}{JUMP} \\
  \hline
  11 00 ij & JFRA ij & Ajoute \$[i][j] à l'adresse de lecture (saut en avant relatif). \\
  11 01 ij & JBRA ij & Retranche \$[i][j] à l'adresse de lecture (saut en arrière relatif). \\
  11 10 ij & IIO  ij & Saute une instruction si le registre donné est non nul. \\
  11 11 0i & JAA  i  & Saut à une adresse absolue donnée par \$[i]0.\$[i]1\\
  11 11 10 & WCA     & \'Ecrit l'adresse courante dans \$a0.\$a1. \\
  11 11 11 & END      & Termine le programme. \\
  \hline

\caption{Instructions microprocesseur}
\end{longtable}
\end{savenotes}

On peut constater qu'il manque 2 instructions dans ce tableau, les 2 premières.
La toute première, l'instruction 00 00 00, a volontairement été laissée inactive
car c'est la valeur que prennent toutes les cases de la ROM par défaut. Il était
important pour aider au déboguage qu'elle ne fasse rien et peut s'avérer utile
si on fait des sauts de taille approximative et que l'on a donc besoin d'ajuster,
ce qui peut être le cas lorsque l'on cherche à optimiser le code en profitant du
fait qu'une certaine valeur soit déjà chargée dans un registre.

\paragraph{}Pour l'instruction restante, elle ne fait rien non plus mais uniquement car
on ne lui a pas trouvé de rôle. Elle fait partie de l'unitée système et est trop
peu nombreuse pour ajouter par exemple une fonction de lecture des registres graphiques.
On ne pouvait lui donner de rôle sans aboutir à un jeu d'instruction complètement incohérent.


\subsection{Outils de développement}

\paragraph{}Le microprocesseur doit être décrit sous forme de netlist. On se rend cependant très vite compte en faisant quelques essais que rédiger directement en netlist est extrêmement fastidieux (et de fait, on manipulera par moment des netlist de près de 30 000 lignes). De nombreuses portions du code se répètent, certaines sont paramétriques et si on décide de changer la taille des mots machine par exemple on est bien embêté.

\paragraph{}C'est pourquoi il est impératif d'utiliser une description plus haut niveau. Il y a pour cela deux possibilités :
\begin{itemize}
	\item utiliser un programme générant directement la netlist pour le micro
	\item compiler en netlist depuis un langage de description de circuits plus haut niveau.
\end{itemize}

\paragraph{}Un compilateur minijazz étant fourni, nous avons choisi la seconde option. Ce choix a cependant posé plusieurs problèmes.

Premièrement, minijazz étant un langage très simple, il ne gère pas l'import de fichiers les uns dans les autres. Cette fonctionnalité nous semblait pourtant essentielle, d'une part pour pouvoir utiliser une même portion de circuit dans plusieurs tests distincts (par exemple le gpu et l'alu) et d'autre part pour pouvoir travailler sans se gêner sur le circuit (git gère bien mieux des fichiers séparés). Nous avons donc rajouté cette fonctionnalité.

Deuxièmement, les messages d'erreur de mjc étaient assez obscurs, que ce soit les « \texttt{The following constraint is not satisfied: ((8 = 0) ? 1 : (8 = (((0 <= (8 - 1)) ? (((8 - 1) - 0) + 1) : 0) + ((0 <= (8 - 8)) ? (((8 - 8) - 0) + 1) : 0))))} » ou les erreurs localisées « Quelque part entre la première et la dernière ligne du fichier ». Le debogage consistait donc en une longue dichotomie sur tout le code du microprocesseur.



\section{Programme}

\begin{wrapfigure}{r}{0.15\textwidth}
\begin{center}
\includegraphics[width=0.15\textwidth]{zoom_prog.eps}
\end{center}
\end{wrapfigure}

\paragraph{}L'assembleur a été nommé « jupiter » et se trouve donc, avec le programme, dans le répertoire du même nom. Le programme a été loin d'être la partie la plus simple du fait des restrictions drastiques imposées au jeu d'instructions. Il a a fallu jongler avec les quatres seuls registres présents et surtout le \emph{load immediat} restreint à 3 bits.

\paragraph{}Nous avons commencé par des tests simples, comme un unique compteur qui nécessitait déjà une vingtaine d'instructions. Dès l'ajout d'un seuil à 60, la difficulté du chargement de constante s'est présentée. Afin d'alléger la boucle principale, il était clair que nous devions charger les constantes à l'avance. Et à force de charger des constantes (60, 24, 30, etc) il a également fallu charger une constante à l'avance pour l'adresse de début de la boucle principale. Notre assembleur n'effectue pas lui-même l'édition des liens donc il est important pour l'optimisation de maîtriser où exactement est enregistrée cette constante. Par exemple plutôt que de faire un LI sur plus de 3 bits (donc en plusieurs étapes), on peut préférer exploiter la valeur précédemment chargée et y ajouter une petite valeur.

\paragraph{}Il a également fallu conserver en RAM la valeur des différents compteurs car une fois envoyés au processeur graphique, elles ne peuvent plus être lues. Nous avons alors dû organiser la mémoire de façon cohérente et avons adopté le schéma suivant :

\paragraph{}$\overline{\underbrace{\underline{|13|24|29|30|31|32|60|100|}}_{chunk 0}\underbrace{\underline{|j|m|a1|a2|h|mn|s|*|}}_{chunk 1}\underbrace{\underline{|L0|*|L2|*|*|*|*|oldInput|}}_{chunk 2}}$

\paragraph{}On notera que la constante L2 est à l'adresse 2 et non à l'adresse 1 qui est libre. C'est parce qu'elle sert de valeur de jump pour éviter un retour en début de boucle (situation se répétant souvent dans le code) et que la constante 2 est utilisée systématiquement juste avant dans le code.

\paragraph{}Une convention a été mise en place dans la rédaction du code assembleur : le niveau d'indentation correspond à la valeur du registre \$c. Cette convention quelque peu exotique s'est avérée utile pour éviter des erreurs qui auraient pu être longues à déboguer.

\paragraph{}Une fois le code fait pour un compteur et le chargement bien organisé, il suffisait à peu près de copier-coller pour obtenir les autres compteurs. La principale difficulté fut de gérer le nombre de jours par mois. Nous avons commencé par chercher à partir de la table de vérité à construire par opérations bits à bits l'adresse mémoire contenant le nombre de jours, mais cette opération était, malgré des simplifications heureuses, coûteuse. Nous avons finalement utilisé l'important espace mémoire disponible pour construire lors de la phase d'initialisation une \emph{look up table} contenant le nombre de jour pour chaque mois (enfin l'adresse mémoire la contenant, pour simplifier l'initialisation).

\paragraph{}La dernière difficulté fut de gérer les années bisextiles. Détecter si le mois est février puis si l'année est bisextile demande un grand nombre d'opérations à effectuer chaque mois, surtout que faire un branchement conditionnel nécessite de charger qu préalable le nombre d'opérations à sauter si la condition n'est pas remplie. Nous avons finalement choisi d'éditer la LUT au changement d'année.

\paragraph{}Le code a été réfléchi pour exploiter au maximum la moindre de ses instructions, à l'exception du chargement de la date initiale. En effet, on peut dans des cas particulier accélérer le chargement de constantes (en jouant sur le nombre de bits finaux nuls, des négations, etc) mais nous voulions avoir la possibilité, ne serait-ce que pour les tests, de pouvoir modifier la date initiale facilement. Nous sommes même allé plus loin en écrivant un petit script (\texttt{jupiter/preprocessor.sh}) insérant les constantes au bon endroit (bien qu'il faille tout de même donner les constantes en binaire et 3 bits par 3 bits dans ce script, il n'est pas très \emph{user-friendly}) et supprimant la partie du code attendant la seconde suivante dans le cas où on veut faire tourner l'horloge à pleine vitesse.





\section{Oscillateur}

\begin{figure}[h]
\centering
\includegraphics[height=4em]{zoom_input.eps}
\end{figure}

\paragraph{}La question de la source de temps s'est posée assez vite. Nous avions le choix entre fixer la cadence du processeur et compter les instructions ou envoyer un signal périodique en entrée. Nous avons choisi la seconde option, plus souple et plus proche de la réalité, et nous avons même décidé de ne pas utiliser l'horloge de l'ordinateur mais un circuit électronique réel.


\begin{figure}[h]
\centering
\includegraphics{oscillator.jpg.eps}
\caption{\label{schema} Schéma de l'oscillateur carré utilisé}
\end{figure}
\paragraph{}Le circuit, oscillateur carré, est réalisé à l'aide de deux portes NOT (enfin des portes NANDs avec les deux entrées reliées dans la pratique), deux résistances et un condensateur, comme le montre la figure \ref{schema}.

Afin de contrôler la période des oscillation et l'ajuster au plus près d'une seconde, nous avons remplacé la résistance centrale par un potentiomètre et avons ainsi atteint une précision de $10^{-3}$s.


\begin{figure}[h]
\centering
\includegraphics{sysdig_clock.eps}
\caption{\label{arduino_schema} Schéma du montage avec l'arduino}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth,height=0.9\textheight,keepaspectratio]{arduino.jpg.eps}
\caption{\label{arduino_photo} Photographie du montage avec l'arduino. Ici l'arduino est branché (par le fil orange) à un bouton servant pour les tests.}
\end{figure}

\paragraph{}La deuxième étape consiste à interfacer cet oscillateur avec l'ordinateur. Nous utilisons pour celà un arduino avec un programme extrêmement simple : lire le pin 2 et écrire sa valeur sur le port série. Le port série est ensuite lu par un programme sur l'ordinateur et envoyé par piping sur l'entrée de la simulation. Le schéma du montage avec l'arduino est présenté en figure \ref{arduino_schema} et une photographie du montage réel est en figure \ref{arduino_photo}.

\paragraph{}Concernant la lecture du port série depuis l'ordinateur, nous avons tout d'abord rédigé un script python, mais finalement il suffit de faire \texttt{cat < /dev/ttyACM0} pour lire le port série de ttyACM0 (ce nom peut varier d'une machine à l'autre, entre ttyACM* et ttyUSB* généralement). Le seul problème est de configurer correctement le port (baudrate, bit de parité, etc) et pour cela la commande \texttt{stty} est utilisée mais ne donne pas toujours les résultats escomptés. La seule solution trouvée est de lancer \texttt{minicom} et d'y configurer le port en « \texttt{9600 8N1} ». Après l'avoir coupé, les paramètres restent actifs.


\paragraph{}Les résultats obtenus sont assez précis (nous avons testé la simulation sur 3h pour vérifier le comportement du circuit (réel) à chaud). Différents graphes et tableaux sont disponibles à cette adresse : \url{https://github.com/eliemichel/sysdig/wiki/Horloge} (je ne les insère pas ici pour éviter de surcharger). On voit qu'il y a une déviation très régulière essentiellement due au maque de précision de notre potentiomètre.


\section{Afficheurs}

\begin{figure}[h]
\centering
\includegraphics[height=4em]{zoom_output.eps}
\end{figure}
Nous avons deux afficheur : l'un graphique, par soucis d'esthétisme et pour rendre quelque chose de présentable ; l'autre en console permettant d'afficher facilement toutes sortes d'informations.

\subsection{Afficheur non graphique}
\paragraph{}Toute la logique étant dans le micro, l'afficheur est assez simple. Il doit lire son entrée et décoder les 7 segments (juste après qui aient été codés…) pour les afficher sous forme d'entiers dans la console.

\paragraph{}Il calcule et affiche en plus la fréquence (moyenne et instantanée) du simulateur ainsi qu'un compteur affichant les secondes réelles (enfin réelles… selon l'horloge de l'ordinateur). Il peut aussi facilement s'adapter si on demande au micro de donner plus de sorties afin de simplifier le déboguage.

\subsection{Afficheur graphique}
\paragraph{}Il devait au début être fait en python en illustrant directement le fait que les sorties du micro sont branchées sans aucune autre forme de logique aux segments de l'afficheur, mais nous sommes tombé par hasard sur cette page : \url{raphaeljs.com/polar-clock.html} montrant un exemple de démonstration d'une bibliothèque graphique javascript représentant une horloge !

\paragraph{}Nous avons voulu la « brancher » à notre simulateur, mais ce n'était pas évident car c'est en fait une page web. Nous avons donc codé un petit serveur local avec NodeJS écoutant l'entrée standard pour envoyer, \emph{via} les web sockets (et la bibliothèque \texttt{socket.io}), les informations à la page web lancée dans le navigateur, à l'adresse \texttt{http://localhost:3616}.

\paragraph{}Cet afficheur étant imprévu et fait un peu vite à la fin, il n'est pas totalement au point au niveau du nombre de jours par mois. Les graduations ne changent pas et il est fixé à 30 jours, ce qui entraîne un comportement un peu particulier lors de l'envoi d'une date supérieure.


\end{document}
