(******************************************************************************)
(* empty                                                                      *)
empty<n>() = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = 0 . empty<n-1>()
  end if
end where

(******************************************************************************)
(* mux_n                                                                      *)
(* mux( a, b, c ) = a si c = 1                                                *)
(*                  b sinon                                                   *)
mux_n<n>(a:[n], b:[n], c) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = mux(a[0], b[0], c) . mux_n<n-1>(a[1..], b[1..], c)
  end if
end where

(******************************************************************************)
(* reg_n                                                                      *)
reg_n<n>(a:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = (reg a[0]).reg_n<n-1>(a[1..])
  end if
end where

(******************************************************************************)
(* fulladder                                                                  *)
(* a+b+c = s et reste r                                                       *)
fulladder(a, b, c) = (s, r) where
  s = (a xor b) xor c;
  r = (a and b) or ((a xor b) and c);
end where

(******************************************************************************)
(* nadder                                                                     *)
(* Endian CHECK                                                               *)
nadder<n>(a:[n], b:[n], r_in) = (o:[n], r_out) where
  if n=0 then
    o     = [];
    r_out = r_in
  else
    (s, r)   = fulladder( a[0] , b[0] , r_in );
    (o', r') = nadder<n-1>( a[1..] , b[1..] , r );
    o = s . o';
    r_out = r'
  end if
end where

(******************************************************************************)
(* add                                                                        *)
(* add<n>(a,b) = o + 2^n.r                                                    *)
add<n>(a:[n], b:[n]) = (o:[n], r) where
  (o, r) = nadder<n>(a, b, 0)
end where

(******************************************************************************)
(* fullsubber                                                                 *)
(* Il faudrait trouver une autre orthographe, c'est moche.                    *)
(* Fait la soustraction a-b-c, et mets son bit r à 1 si le résultat entraine  *)
(* une retenue de -1.                                                         *)
(* VERIFIE PAR TABLE DE VERITE : OK                                           *)
fullsubber(a, b, c) = (s, r) where
  s = ((not a) and (b xor c)) or (a and (not(b xor c)));
  r = ((not a) and (b or c)) or (a and b and c)
end where

(******************************************************************************)
(* nsubber                                                                    *)
(* Même remarque...                                                           *)
(* Ajoutons quand même que la construction de nsubber est 'exactement' la     *)
(* même que celle de nadder, mais en appelant fullsubber. Ca veut d'ailleurs  *)
(* dire qu'on peut regrouper ces deux fonctions en une seule, qui serait      *)
(* contrôlée par un bit addition ou soustraction.                             *)
nsubber<n>(a:[n], b:[n], r_in) = (o:[n], r_out) where
  if n=0 then
    o     = [];
    r_out = r_in
  else
    (s, r)   = fullsubber( a[0] , b[0] , r_in );
    (o', r') = nsubber<n-1>( a[1..] , b[1..] , r );
    o = s . o';
    r_out = r'
  end if
end where

(******************************************************************************)
sub<n>(a:[n], b:[n]) = (o:[n], r) where
  (o, r) = nsubber<n>(a, b, 0)
end where

(******************************************************************************)
(* Division euclidienne                                                       *)
div_mn<n,m>(a:[n],b:[n]) = (q:[m],r:[n]) where
  if m=0 then
    q = [];
    r = a
  else
    a' = a[m-1..] . empty<m-1>();
    (res, con) = sub<n>(a', b);
    res' = a[..m-2] . res[..n-m];      (* On recompose le résultat *)

    (* Les deux lignes suivantes créaient 2^n divisions... C'est beaucoup. *)
    (* (q1, r1) = div_mn<n,m-1>(a, b);      (* Si con=1 *) *)
    (* (q0, r0) = div_mn<n,m-1>(res', b);   (* Si con=0 *) *)
    (* Donc on va corriger ça par la ligne suivante : *)

    a'' = mux_n<n>( a , res' , con );
    (q', r) = div_mn<n,m-1>( a'', b);
    q = q' . (not(con));
  end if
end where
div<n>(a:[n],b:[n]) = (q:[n],r:[n]) where
  (q,r) = div_mn<n,n>(a,b)
end where

(* L'HEURE DU TEST *)
main(a:[16],b:[16]) = (q:[16],r:[16]) where
  (q,r) = div<16>(a,b)
end where

