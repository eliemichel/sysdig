(******************************************************************************)
(* empty                                                                      *)
empty<n>() = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = 0 . empty<n-1>()
  end if
end where

(******************************************************************************)
(* null_n( a ) = a == 00...0                                                    *)
null_n<n>(a:[n]) = (o) where
  if n = 0 then
    o = 1
  else
    o = not(a[0]) and null_n<n-1>(a[1..]);
  end if
end where

(******************************************************************************)
(* full_n( a ) = a == 11...1                                                    *)
full_n<n>(a:[n]) = (o) where
  if n = 0 then
    o = 1
  else
    o = a[0] and full_n<n-1>(a[1..]);
  end if
end where

(******************************************************************************)
(* mux_n                                                                      *)
(* mux( a, b, c ) = a si c = 1                                                *)
(*                  b sinon                                                   *)
mux_n<n>(a:[n], b:[n], c) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = mux(a[0], b[0], c) . mux_n<n-1>(a[1..], b[1..], c)
  end if
end where

(******************************************************************************)
(* mux_n                                                                      *)
(* mux( v00, v01, v10, v11, c0, c1 ) = v[c0][c1]                              *)
(*                  b sinon                                                   *)
mux4_n<n> (v00:[n], v01:[n], v10:[n], v11:[n], c0, c1) = (v:[n]) where
  v0 = mux_n<n>(v01, v00, c1);
  v1 = mux_n<n>(v11, v10, c1);
  v  = mux_n<n>(v1, v0, c0);
end where


(******************************************************************************)
(* reg_n                                                                      *)
reg_n<n>(a:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    o = (reg a[0]).reg_n<n-1>(a[1..])
  end if
end where

(******************************************************************************)
(* fulladder                                                                  *)
(* a+b+c = s et reste r                                                       *)
fulladder(a, b, c) = (s, r) where
  s = (a xor b) xor c;
  r = (a and b) or ((a xor b) and c);
end where

(******************************************************************************)
(* add                                                                        *)
(* Endian CHECK                                                               *)
nadder<n>(a:[n], b:[n], r_in) = (o:[n], r_out) where
  if n=0 then
    o     = [];
    r_out = r_in
  else
    (s, r)   = fulladder( a[0] , b[0] , r_in );
    (o', r') = nadder<n-1>( a[1..] , b[1..] , r );
    o = s . o';
    r_out = r'
  end if
end where
add<n>(a:[n], b:[n]) = (o:[n], r) where
  (o, r) = nadder<n>(a, b, 0)
end where

(******************************************************************************)
(* Multiplication                                                             *)
(* Le résultat est renvoyé dans r[0]...r[n-1].q[0]...q[n-1]                   *)
(* PROBLEME DE COMPATILIBILITE DES ARGUMENTS A TROUVER...                     *)
mult_nm<n,m>( a:[n] , b:[n] ) = ( r:[n] , q:[n] ) where
  if m=0 then
    q = empty<n>();
    r = empty<n>()
  else
    (q', r') = mult_nm<n,m-1>( a , b );

    qp = mux_n<n>( b[n-m+1..] . empty<n-m+1>() , empty<n>() , a[m-1] );
    rp = mux_n<n>( empty<m-1>() . b[..n-m] , empty<n>(), a[m-1] );
    
    (r, bit) = add<n>( rp , r');
    (q, pbit) = nadder<n>( qp , q' , bit ); (* pointless bit (pas de dép.) *)
  end if
end where
mult<n>( a:[n] , b:[n] ) = ( q:[n] , r:[n] ) where
  (q,r) = mult_nm<n,n>(a,b)
end where

(******************************************************************************)
(* fullsubber                                                                 *)
(* Il faudrait trouver une autre orthographe, c'est moche.                    *)
(* Fait la soustraction a-b-c, et mets son bit r à 1 si le résultat entraine  *)
(* une retenue de -1.                                                         *)
(* VERIFIE PAR TABLE DE VERITE : OK                                           *)
fullsubber(a, b, c) = (s, r) where
  s = ((not a) and (b xor c)) or (a and (not(b xor c)));
  r = ((not a) and (b or c)) or (a and b and c)
end where

(******************************************************************************)
(* nsubber                                                                    *)
(* Même remarque...                                                           *)
(* Ajoutons quand même que la construction de nsubber est 'exactement' la     *)
(* même que celle de nadder, mais en appelant fullsubber. Ca veut d'ailleurs  *)
(* dire qu'on peut regrouper ces deux fonctions en une seule, qui serait      *)
(* contrôlée par un bit addition ou soustraction.                             *)
nsubber<n>(a:[n], b:[n], r_in) = (o:[n], r_out) where
  if n=0 then
    o     = [];
    r_out = r_in
  else
    (s, r)   = fullsubber( a[0] , b[0] , r_in );
    (o', r') = nsubber<n-1>( a[1..] , b[1..] , r );
    o = s . o';
    r_out = r'
  end if
end where
sub<n>(a:[n], b:[n]) = (o:[n], r) where
  (o, r) = nsubber<n>(a, b, 0)
end where

(******************************************************************************)
(* Division euclidienne                                                       *)
div_mn<n,m>(a:[n],b:[n]) = (q:[m],r:[n]) where
  if m=0 then
    q = [];
    r = a
  else
    a' = a[m-1..] . empty<m-1>();
    (res, con) = sub<n>(a', b);
    res' = a[..m-2] . res[..n-m];      (* On recompose le résultat *)

    (* Les deux lignes suivantes créaient 2^n divisions... C'est beaucoup. *)
    (* (q1, r1) = div_mn<n,m-1>(a, b);      (* Si con=1 *) *)
    (* (q0, r0) = div_mn<n,m-1>(res', b);   (* Si con=0 *) *)
    (* Donc on va corriger ça par les lignes suivantes. *)

    a'' = mux_n<n>( a , res' , con );
    (q', r) = div_mn<n,m-1>( a'', b);
    q = q' . (not con);
  end if
end where
div<n>(a:[n],b:[n]) = (q:[n],r:[n]) where
  (q,r) = div_mn<n,n>(a,b)
end where

(******************************************************************************)
(* not_n                                                                      *)
not_n<n>(a:[n])=(o:[n]) where
  if n=0 then
    o = []
  else
    o = (not a[0]) . (not_n<n-1>(a[1..]))
  end if
end where

(******************************************************************************)
(* or_n                                                                       *)
or_n<n>(a:[n],b:[n])=(o:[n]) where
  if n=0 then
    o = []
  else
    o = (a[0] or b[0]) . (or_n<n-1>(a[1..],b[1..]))
  end if
end where

(******************************************************************************)
(* and_n                                                                      *)
and_n<n>(a:[n],b:[n])=(o:[n]) where
  if n=0 then
    o = []
  else
    o = (a[0] and b[0]) . (and_n<n-1>(a[1..],b[1..]))
  end if
end where

(******************************************************************************)
(* eq_n                                                                       *)
(* Pas besoin non plus, soustraction le fait aussi !                          *)

(******************************************************************************)
(* inf_n(a,b) = a<b                                                           *)
(* Finalement, on a pas besoin de l'inf, puisque la soustraction le fait.     *)

(******************************************************************************)
(* shift                                                                      *)
(* ATTENTION. Le "left" et "right" est au sens gauche et droite des nombres   *)
(* binaires qu'on regarde ! left(01(2)) = 0|10(2), right(01(2)) = 00|1(2)     *)
shift<n>( a:[n] , b:[n] ) = ( left_a:[n] , right_b:[n] ) where
  left_a  = 0 . a[..n-2];
  right_b = b[1..] . 0
end where

(* /!\ ATTENTION : Les fonctions suivante sont efficace pour une petite valeur*)
(* de n seulement. Si n > 8, il est préférable d'utiliser add et sub qui sont *)
(* de complexité linéaire et non quadratique.                                 *)

(******************************************************************************)
(* incr_n(a) = a+1                                                            *)
incr_n<n>(a:[n]) = (o:[n]) where
  if n = 0 then
    o = []
  else
    b = incr_n<n-1>(a[1..]);
    o = mux_n<n>(0 . b, 1. a[1..], a[0])
  end if
end where

(* incr_n et decr_n n'ont pas la même signature malgré la proximité de leur   *)
(* nom mais c'est dû à leur utilisation totalement différente.                *)
(******************************************************************************)
(* decr_n(a) = a-1                                                            *)
decr_n<n>(a:[n]) = (o:[n], r) where
  if n = 0 then
    o = [];
    r = 1
  else
    a0 = a[0];
    (b, r') = decr_n<n-1>(a[1..]);
    o = mux_n<n>(0 . a[1..], 1 . b, a0);
    r = mux(0, r', a0);
  end if
end where

(******************************************************************************)
(* Registre à enable de taille n                                              *)
enableReg<n> (writeVal:[n], enable) = (val:[n]) where
  newVal = mux_n<n>(writeVal, val, enable);
  val = reg_n<n>(newVal);
end where


